import sun.nio.ch.IOUtil;

import java.io.*;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

public class mytest {

    public static void main(String[] args) {
        String outputDir = "C:\\Users\\gouwe\\Downloads\\Video\\新建文件夹";
        try {

            FileOutputStream out = new FileOutputStream(outputDir + "\\合并.pdf", true);
            for (int i = 0; i < 4; i++) {
                FileInputStream in = new FileInputStream(outputDir + "\\part-" + (i + 1) + ".txt");
                byte[] buffer = new byte[1024];
                int len;
                while ((len = in.read(buffer)) != -1) {
                    out.write(buffer, 0, len);
                }

                in.close();
            }


            out.close();
        } catch (Exception e) {
            e.printStackTrace();

        }
        //part - 1. txt


    }

    private static void extracted() {
        String inputFilePath = "E:\\桌面链接\\github仓库\\java-EE\\8.java_网络编程\\Netty进阶之路 跟着案例学Netty (李林锋) (Z-Library).pdf";

        String outputDir = "C:\\Users\\gouwe\\Downloads\\Video\\新建文件夹"; // 替换为输出目录路径
        int chunkSize = 50 * 1024 * 1024; // 设置每个分片的大小，这里为1MB

        try {
            File inputFile = new File(inputFilePath);
            File outputDirFile = new File(outputDir);
            if (!outputDirFile.exists()) {
                outputDirFile.mkdirs();
            }

            FileInputStream fis = new FileInputStream(inputFile);
            FileChannel channel = fis.getChannel();

            long fileSize = channel.size();
            long chunkCount = (fileSize + chunkSize - 1) / chunkSize;

            for (long i = 0; i < chunkCount; i++) {
                long startPosition = i * chunkSize;
                long endPosition = Math.min(startPosition + chunkSize, fileSize);

                String outputFileName = outputDir + "/part-" + (i + 1) + ".txt";
                FileOutputStream fos = new FileOutputStream(outputFileName);
                FileChannel targetChannel = fos.getChannel();

                // 映射文件到ByteBuffer
                MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY
                        , startPosition
                        , endPosition - startPosition);

                // 将ByteBuffer的内容写入目标文件

                targetChannel.write(buffer);

                // 关闭流和通道
                fos.close();
                targetChannel.close();
            }

            // 关闭输入文件的流和通道
            fis.close();
            channel.close();

            System.out.println("File splitting completed.");

        } catch (IOException e) {
            e.printStackTrace();
        }
    }


}
